/*
 * Assignment 02
 * File:    Corpus.java
 * Date:    26 January 2018
 * Author:  Matthew Morgan
 * Description:
 * Corpus contains functions for reading the corpus and generating a positional index.
 * It uses the classes in Token.java to create the positional indices.
 *
 * Accepted Arguments:
 * -indNew   Toggles overwriting of the current index (if there is one)
 * -query[f] Toggles the loading of queries from a text file, f
 * 
 * Bucketlist:
 * - Advanced querying (~and, ~or, ~not, and parenthetical grouping), using recursive
 *   algorithm to perform intersections one by one
 * - Automatic corpus entry generator, if a corpus entry document is not available, but
 *   a directory is specified as the first argument for execution
 * - Previous query result storage (in Query.java) and pagination of results
 *   generated by a query (using a ~pg command)
 */

// Import statements
import java.util.Hashtable;
import java.util.ArrayList;
import java.util.Collections;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Scanner;

public class Corpus {
    // dictionary is a hashtable of tokens that store postings lists amongst the documents
    // INDEX_OVERWRITE is a boolean toggle for whether or not to overwrite the index during execution
    // query is a reference to the Query object that will handle inquiries into the corpus' index
    private static Hashtable<String,Token> dictionary = new Hashtable<>();
    private static boolean INDEX_OVERWRITE = false;
    private static Query query = new Query();

    // DIR_INDEX is a constant, specifying the index directory
    // FIL_DOCS is a constant, specifying the location of the document association text file
    // EXT_TOKEN is a constant, specifying the file extension of token text files
    public static final String DIR_INDEX = "./index/",
        FIL_DOCS = DIR_INDEX + "documents.ind",
        EXT_TOKEN = ".tok";

    public static void main(String[] args) {
        argumentCheck(args);

        // Read data from the corpus and update the index ONLY if index creation (or reset)
        // is successful. Creation is successful if the index doesn't exist or the toggle
        // for overwriting the index is set.
        if (indexCreate()) {
            System.out.println("Please wait while the index is constructed...");
            ArrayList<String> corpus = readCorpus(args[0]);
            generateCorpus(corpus);
            indexSave(corpus);
        }

        // Clear the Hashtable to clear up memory before processing phrase queries
        dictionary.clear();
        query.query();
    }

    /**
     * Checks CLI arguments passed to the program
     * @param args The set of arguments passed to the program
     */
    public static void argumentCheck(String[] args) {
        // Flag for if an error was found in arguments
        boolean errorFound = !(args.length >= 1);

        try {
            // Extra arguments not mandated by the program for execution
            for(int i=1; i<args.length; i++) {
                String arg = args[i];

                // Query input redirection test
                // Index overwrite modifier test
                if (arg.contains("-query")) {
                    query.QUERY_REDIRECT = true;
                    query.filQuery = arg.substring(arg.indexOf('[')+1).replace("]","");
                }
                else if (arg.equals("-indNew"))
                    INDEX_OVERWRITE = true;
                else
                    errorFound = true;
            }
        }
        catch(Exception e) {
            System.err.println("Invalid argument has been detected!");
            errorFound = true;
        }

        // Return from this function if no error was found
        if (!errorFound) { return; }

        // Print proper usage
        System.err.println("Usage: java CorpusQuery <infile-corpus> [-indNew] [-query[f]]");
        System.err.println("Options:");
        System.err.println("  indNew   Specifies that the current index (if any) should be overwritten");
        System.err.println("  query[f] Redirects query processing to the file 'f'");
        System.exit(1);
    }

    /**
     * Reads an input file at the specified path to generate a list of corpus entries
     * to be processed by the program
     * @param path The path of the file to read corpus entries from
     * @return A list of strings representing corpus entries
     */
    public static ArrayList<String> readCorpus(String path) {
        // List of files to be returned at the end
        ArrayList<String> files = new ArrayList<>();

        try {
            // BufferedReader for reading entries in the corpus file and a String to
            // temporarily store filenames
            BufferedReader file = new BufferedReader(new FileReader(new File(path)));
            String entry;

            // While there are filenames still being read from the file, add those names
            // to the list of corpus entries
            while((entry = file.readLine()) != null)
                files.add(entry);

            file.close();
        }
        catch(IOException e) {
            System.err.println("SYS: Error during file handling!");
            System.err.println(e.getMessage());
            System.exit(1);
        }

        // Return the finalized list of files to be read in as a corpus
        return files;
    }

    /**
     * Reads all the entries in the corpus, processing their data to create a dictionary
     * of tokens and their postings lists
     * @param corpus List of filenames that represent entries in the corpus
     */
    public static void generateCorpus(ArrayList<String> corpus) {
        // For each entry in the corpus list, process its data
        for(int i=0; i<corpus.size(); i++) {
            String path = corpus.get(i);

            System.out.println("  "+path);
            
            // Try to open the text file, process it line by line, and then lose the file
            // after finished processing
            try {
                // file will be used to read lines from the file, with each line being
                // stored inside of the variable line. docLoc tracks the current location
                // of document processing
                BufferedReader file = new BufferedReader(new FileReader(new File(path)));
                String line;
                int docLoc = 1;

                // While lines are being read from the file, process those lines
                while((line = file.readLine()) != null)
                    docLoc = processLine(line, i, docLoc);

                file.close();
            }
            catch(IOException e) {
                System.err.printf("SYS: Error during file handling on file '%s'!\n", path);
                System.err.println(e.getMessage());
                System.exit(1);
            }
        }
    }

    /**
     * Processes a line of text from a corpus entry, taking the tokens of the line and updating the current
     * information in the token dictionary
     * @param line The line to be processed
     * @param docID The ID of the document being handled
     * @param docLoc The starting location of the line in the document
     * @return The updated starting location for the next line in the document
     */
    public static int processLine(String line, int docID, int docLoc) {
        // Preprocess the line
        line = preProcessLine(line);

        // Loop through each word in the line, not including blanks (due to multi-space
        // gaps between words, such as "wordA  wordB" becoming "wordA", "", and "wordB")
        // to generate document postings lists
        for(String word : line.split(" ")) {
            if (!word.equals("")) {
                // The token that's been stemmed and a reference to the token object
                // representing the stemmed token
                String token = Token.stemToken(word);
                Token t = dictionary.putIfAbsent(token, new Token(token));
                if (t == null)
                    t = dictionary.get(token);

                // Add the document to the index if it doesn't exist yet
                if (!t.isInDoc(docID))
                    t.addDoc(docID);

                t.addDocLocation(docID, docLoc);
                docLoc++;
            }
        }

        // Return the updated location in the document
        return docLoc;
    }

    /**
     * Attempts to create the index if it doesn't exist, returning the result of this attempt
     * @return True if the index was successfully created, or false if it already exists
     */
    public static boolean indexCreate() {
        // Attempt to check the existence of the index directory, and create it if it doesnt exist
        // or attempt to erase all files in the directory if an overwrite is scheduled
        try {
            // Reference to the index's directory
            File index = new File(DIR_INDEX), docs = new File(FIL_DOCS);

            // If the index exists, print that it's been detected. If it doesn't, create the directory
            // for it. If it's being overwritten, erase the files already in the index for rewrite
            if (index.exists() && docs.exists() && !INDEX_OVERWRITE) {
                System.out.println("An index has been detected as constructed... Skipping generation...");
                return false;
            }
            else if (!index.exists() || !docs.exists())
                index.mkdir();
            else
                for(File f : index.listFiles()) { f.delete(); }
        }
        catch(Exception e) {
            System.err.println("SYS: An error occured during index creation!");
            System.err.println(e.getMessage());
            System.exit(1);
        }

        return true;
    }

    /**
     * Writes index information to the disk for future access
     * @param corpus The list of entries in the corpus that the index is based on
     */
    public static void indexSave(ArrayList<String> corpus) {
        try {
            // list is a list of the keys (tokens) in the dictionary. file is used for writing data
            // to files in the index. tokCat specifies which tokens are currently being written
            // (for example, 'a' for all tokens starting with an 'a')
            ArrayList<String> list = Collections.list(dictionary.keys());
            BufferedWriter file;
            char tokCat = ' ';

            // Write the entries of the corpus into the "document association" file, where
            // the integer index of an entry serves as its document ID
            file = new BufferedWriter(new FileWriter(new File(FIL_DOCS)));
            file.write(corpus.size()+"\n");
            for(int i=0; i<corpus.size(); i++)
                file.write(corpus.get(i)+"\n");
            file.close();
            file = null;

            // After sorting the list of keys, append token information to token data files
            Collections.sort(list);
            for(String token : list) {
                // Transition to a new token data file if the first character of the next token doesn't
                // match that of the ones being written in the current file.
                if (token.charAt(0)!=tokCat) {
                    if (file!=null) { file.close(); }
                    tokCat = token.charAt(0);
                    file = new BufferedWriter(new FileWriter(DIR_INDEX+tokCat+EXT_TOKEN, true));
                }

                indexSaveToken(dictionary.get(token), file);
            }
            
            file.close();
        }
        catch(IOException e) {
            System.err.println("SYS: Error during index saving!");
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    /**
     * Writes token information to a text file
     * @param t The token to save the information of
     * @param file The file where the token's information is being written
     */
    public static void indexSaveToken(Token t, BufferedWriter file) {
        try {
            file.write(t.getToken()+"\n");
            for(TokenIndexDocument doc : Collections.list(t.getIndex().elements())) {
                // index is the current document's postings list
                ArrayList<Integer> index = doc.getLocations();

                // Write the postings list in the format: { loc loc loc }
                file.write(doc.getID()+" { ");
                for(int i=0; i<index.size(); i++)
                    file.write(index.get(i)+" ");
                file.write("}\n");
            }
        }
        catch(IOException e) {
            System.err.println("SYS: Error during token save!");
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    /**
     * Preprocesses a line of text by removing illegal characters
     * @param line The line of text to be preprocessed
     * @return The line after preprocessing has been completed
     */
    public static String preProcessLine(String line) {
        line = line.toLowerCase();
        String stripped = "";

        // Loop through all the characters of the line to strip away unwanted characters
        // If c satisfies 0 <= c <= 9, or a <= c <= z, or c is a space, it's kept
        // If c is a "-" and the characters before/after are letters/numbers, it's kept
        // If c is a "-" and it has a "-" to the right, a space is appended in its place
        // If c is NOT a "'", a space is appended in its place
        for(int i=0; i<line.length(); i++) {
            // Current character being tested
            char c = line.charAt(i);

            if (isLetorNum(c) || c==' ')
                stripped += Character.toString(c);
            else if (c=='-') {
                // Attempt to get the character before and after the current to test if
                // they're numbers or letters
                try {
                    char p = line.charAt(i-1), n = line.charAt(i+1);
                    if (isLetorNum(p) && isLetorNum(n))
                        stripped += '-';
                    else if (n=='-')
                        stripped += ' ';
                }
                catch(Exception e) { /* Do nothing */ }
            }
            else if (!(c=='\''))
                stripped += ' ';
        }

        return stripped;
    }

    /**
     * Checks if a character is a number or letter
     * @param c The character to check
     * @return True if the character is a letter or number, or false if not
     */
    public static boolean isLetorNum(char c) {
        return (c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z');
    }

    /**
     * Pads a string, on the left, to be the desired length, using the character
     * specified as the padder. No padding is added if the length of the string
     * provided exceeds the parameter 'sLen.'
     * @param s The string to be padded
     * @param padder The character to use for padding
     * @param sLen The desired length of the string, after padding
     */
    public static String padStringLeft(String s, char padder, int sLen) {
        return String.format("%"+sLen+"s", s).replace(' ', padder);
    }
}